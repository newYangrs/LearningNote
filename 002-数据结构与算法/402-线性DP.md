## 线性dp

### 数字三角形

![1615530448983](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1615530448983.png)

#### 数字三角形问题

给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。

```
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```

#### 输入格式

第一行包含整数n，表示数字三角形的层数。

接下来n行，每行包含若干整数，其中第 i 行表示数字三角形第 i 层包含的整数。

#### 输出格式

输出一个整数，表示最大的路径数字和。

#### 数据范围

1≤n≤500
−10000≤三角形中的整数≤10000

#### 输入样例：

```
5
7
3 8
8 1 0 
2 7 4 4
4 5 2 6 5
```

#### 输出样例：

```
30
```

#### 题解：

![1615532027343](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1615532027343.png)

```c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 505 ;
const int INF = 1e9 ;
int a[N][N];
int f[N][N];

int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=i;j++){
            cin>>a[i][j];
        }
    }
    
    for(int i=0;i<=n;i++){
        for(int j=0;j<=i+1;j++){
            f[i][j]=-INF;
        }
    }
    f[1][1]=a[1][1];
    for(int i=2;i<=n;i++){
        for(int j=1;j<=i;j++){
            f[i][j]=max(f[i-1][j-1]+a[i][j],f[i-1][j]+a[i][j]);
        }
    }
    int res = -INF;
    for(int i=1;i<=n;i++){
        res=max(res,f[n][i]);
    }
    cout<<res<<endl;
    return 0;
}
```



### 最长上升子序列

![1615533284491](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1615533284491.png)

![1615533222391](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1615533222391.png)

#### 问题：

给定一个长度为N的数列，求数值严格单调递增的子序列的长度最长是多少。

#### 输入格式

第一行包含整数N。

第二行包含N个整数，表示完整序列。

#### 输出格式

输出一个整数，表示最大长度。

#### 数据范围

1≤N≤1000
−109≤数列中的数≤109

#### 输入样例：

```
7
3 1 2 1 8 5 6
```

#### 输出样例：

```
4
```

#### 题解：

```c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 10010 ;
int a[N];
int f[N];

int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    
    for(int i=1;i<=n;i++){
        f[i]=1;
        for(int j=1;j<i;j++){
            if(a[j]<a[i]){
            	f[i]=max(f[i],f[j]+1);
            }
        }
    }
    
    int res = 0 ;
    for(int i=1;i<=n;i++){
        res=max(res,f[i]);
    }
    
    cout<<res<<endl;
    
    return 0;
    
}
```



### 最长公共子序列

![1615538225770](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1615538225770.png)

#### 题目：

给定两个长度分别为N和M的字符串A和B，求既是A的子序列又是B的子序列的字符串长度最长是多少。

#### 输入格式

第一行包含两个整数N和M。

第二行包含一个长度为N的字符串，表示字符串A。

第三行包含一个长度为M的字符串，表示字符串B。

字符串均由小写字母构成。

#### 输出格式

输出一个整数，表示最大长度。

#### 数据范围

1≤N,M≤1000

#### 输入样例：

```
4 5
acbd
abedc
```

#### 输出样例：

```
3
```

#### 题解：

```c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 1010;
char a[N],b[N];
int f[N][N];

int main(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    for(int i=1;i<=m;i++){
        cin>>b[i];
    }
    
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            f[i][j]=max(f[i-1][j],f[i][j-1]);
            if(a[i]==b[j]){
                f[i][j]=max(f[i][j],f[i-1][j-1]+1);
            }
        }
            
    }
    
    cout<<f[n][m]<<endl;
    
    return 0;
    
}
```





















![1615538728990](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1615538728990.png)



