## 最短路算法

#### **分类：**

![1613807312628](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1613807312628.png)

#### 1.朴素dijstra算法

![1614350481753](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1614350481753.png)

- **模板：**

-  朴素dijkstra算法 —— 模板题 

-  **时间复杂是 O(n2+m)O(n2+m), nn 表示点数，mm 表示边数**

```c++
int g[N][N];  // 存储每条边
int dist[N];  // 存储1号点到每个点的最短距离
bool st[N];   // 存储每个点的最短路是否已经确定

// 求1号点到n号点的最短路，如果不存在则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    for (int i = 0; i < n - 1; i ++ )
    {
        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        // 用t更新其他点的距离
        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);

        st[t] = true;
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```

- **例题：**[AcWing 849. Dijkstra求最短路 I](https://www.acwing.com/problem/content/851/)

- 给定一个n个点m条边的有向图，图中可能存在重边和自环，所有边权均为正值。

  请你求出1号点到n号点的最短距离，如果无法从1号点走到n号点，则输出-1。

  **输入格式**

  第一行包含整数n和m。

  接下来m行每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。

   **输出格式**

  输出一个整数，表示1号点到n号点的最短距离。

  如果路径不存在，则输出-1。

   **数据范围**

  1≤n≤500
  1≤m≤10^5^
  图中涉及边长均不超过10000。

   **输入样例：**

  ```
  3 3
  1 2 2
  2 3 1
  1 3 4
  ```

   **输出样例：**

  ```
  3
  ```

- **题解：**

  ```c++
  #include<iostream>
  #include<stdio.h>
  #include<cstring>
  using namespace std;
  
  const int N = 505;
  int g[N][N];
  int dist[N];
  bool st[N];
  int n,m;
  
  int dijkstra(){
      memset(dist,0x3f,sizeof dist);
      dist[1]=0;
      
      for(int i=0;i<n;i++){
          int t =-1;
          for(int j=1;j<=n;j++){
              if(!st[j]&&(t==-1 ||dist[t]>dist[j])){
                  t=j;
              }
          }
          
          for(int j=1;j<=n;j++){
              dist[j]=min(dist[j],dist[t]+g[t][j]);
              
          }
          st[t]=true;
      }
      if(dist[n]==0x3f3f3f3f){return -1;}
      else{return dist[n];}
      
  }
  
  int main(){
      memset(g,0x3f,sizeof g);
      scanf("%d%d",&n,&m);
      for(int i=0;i<m;i++){
          int x,y,z;
          scanf("%d%d%d",&x,&y,&z);
          g[x][y]=min(g[x][y],z);
          
      }
      
      cout<<dijkstra()<<endl;
      return 0;
      
  }
  ```

  



#### 2. 堆优化版dijkstra

![1614497817738](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1614497817738.png)

-  时间复杂度 O(mlogn)O(mlogn), nn 表示点数，mm 表示边数

```c++
typedef pair<int, int> PII;

int n;      // 点的数量
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储所有点到1号点的距离
bool st[N];     // 存储每个点的最短距离是否已确定

// 求1号点到n号点的最短距离，如果不存在，则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});      // first存储距离，second存储节点编号

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.second, distance = t.first;

        if (st[ver]) continue;
        st[ver] = true;

        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```

- 模板题 [AcWing 850. Dijkstra求最短路 II](https://www.acwing.com/problem/content/852/)

给定一个n个点m条边的有向图，图中可能存在重边和自环，所有边权均为非负值。

请你求出1号点到n号点的最短距离，如果无法从1号点走到n号点，则输出-1。

-  输入格式

第一行包含整数n和m。

接下来m行每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。

-  输出格式

输出一个整数，表示1号点到n号点的最短距离。

如果路径不存在，则输出-1。

-  数据范围

1≤n,m≤1.5×10^5^
图中涉及边长均不小于0，且不超过10000。

-  输入样例：

```
3 3
1 2 2
2 3 1
1 3 4
```

-  输出样例：

```
3
```

- 题解：

  ```c++
  #include<iostream>
  #include<cstring>
  #include<stdio.h>
  #include<queue>
  using namespace std;
  
  const int N = 1.5e5+10;
  int n,m;
  int h[N],e[N],w[N],ne[N],idx;
  bool st[N];
  int dist[N];
  typedef pair<int ,int> PII;
  
  void add(int x,int y,int z){
      e[idx]=y;
      w[idx]=z;
      ne[idx]=h[x];
      h[x]=idx++;
      
  }
  
  int dijkstra(){
      memset(dist,0x3f,sizeof dist);
      dist[1]=0;
      priority_queue<PII,vector<PII>,greater<PII>> heap;
      heap.push({dist[1],1});
      
      while(heap.size()){
          auto t = heap.top();
          heap.pop();
          int ver = t.second, distance = t.first;
          if(st[ver]) { continue; }
          st[ver]=true;
          
          for(int i = h[ver];i!=-1;i=ne[i]){
              int j=e[i];
              if(dist[j]>distance+w[i]){
                  dist[j]=distance+w[i];
                  heap.push({dist[j],j});
              }
              
          }
          
      }
      
      
      if(dist[n]==0x3f3f3f3f) return -1;
      else return dist[n];
      
      
  }
  
  int main(int argc,char* argv[]){
  	memset(h,-1,sizeof h);
      memset(w,0x3f,sizeof w);
      cin>>n>>m;
      
      for(int i=0;i<m;i++){
  		int x,y,z;
          scanf("%d%d%d",&x,&y,&z);
          add(x,y,z);
      }
      
      cout<<dijkstra()<<endl;
      
      return 0;
      
  }
  
  ```

  

#### 3.bellman-ford算法（有边数限制的最短路）

- 随便存边
- 适用于有边数限制的最短路问题

![1614586045472](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1614586045472.png)

-  Bellman-Ford算法

-  时间复杂度 O(nm)O(nm), nn 表示点数，mm 表示边数

- 注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。

```c++
int n, m;       // n表示点数，m表示边数
int dist[N];        // dist[x]存储1到x的最短路距离

struct Edge     // 边，a表示出点，b表示入点，w表示边的权重
{
    int a, b, w;
}edges[M];

// 求1到n的最短路距离，如果无法从1走到n，则返回-1。
int bellman_ford()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。
    for (int i = 0; i < n; i ++ )
    {
        for (int j = 0; j < m; j ++ )
        {
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            if (dist[b] > dist[a] + w)
                dist[b] = dist[a] + w;
        }
    }

    if (dist[n] > 0x3f3f3f3f / 2) return -1;
    return dist[n];
}
```

- 模板题 [AcWing 853. 有边数限制的最短路](https://www.acwing.com/problem/content/855/)

给定一个n个点m条边的有向图，图中可能存在重边和自环， **边权可能为负数**。

请你求出从1号点到n号点的最多经过k条边的最短距离，如果无法从1号点走到n号点，输出impossible。

注意：图中可能 **存在负权回路** 。

-  输入格式

第一行包含三个整数n，m，k。

接下来m行，每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。

-  输出格式

输出一个整数，表示从1号点到n号点的最多经过k条边的最短距离。

如果不存在满足条件的路径，则输出“impossible”。

-  数据范围

1≤n,k≤500
1≤m≤10000
任意边长的绝对值不超过10000。

-  输入样例：

```
3 3 1
1 2 1
2 3 1
1 3 3
```

-  输出样例：

```
3
```

- 题解：

```c++
#include<iostream>
#include<cstring>
#include<stdio.h>
using namespace std;

const int N=510;
const int M=10010;

int n,m,k;

int dist[N],backup[N];

struct edges{
    int a,b,w;
}edges[M];

int bellman_ford(){
    memset(dist,0x3f,sizeof dist);
    dist[1]=0;
    for(int i=0;i<k;i++){
        memcpy(backup,dist,sizeof dist);
        for(int j=0;j<m;j++){
            int a=edges[j].a,b=edges[j].b,w=edges[j].w;
            if(dist[b]>backup[a]+w){
                dist[b]=backup[a]+w;
            }
        }
    }
    
    if(dist[n]>0x3f3f3f3f/2) return -1;
    else return dist[n];
    
}

int main(int argc,char* argv[]){
    cin>>n>>m>>k;
    for(int i=0;i<m;i++){
        int a,b,w;
        cin>>a>>b>>w;
        edges[i]={a,b,w};
        
    }
    
    
   int t=bellman_ford();
    
    if(t==-1) puts("impossible");
    else cout<<t<<endl;
    
    return 0;
    
}

```



####  4.spfa 算法（队列优化的Bellman-Ford算法） 

![1614667958662](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1614667958662.png)





- 时间复杂度 平均情况下 O(m)O(m)，最坏情况下 O(nm)O(nm), nn 表示点数，mm 表示边数

```c++
int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储每个点到1号点的最短距离
bool st[N];     // 存储每个点是否在队列中

// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1
int spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue<int> q;
    q.push(1);
    st[1] = true;

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```

- 模板题 [AcWing 851. spfa求最短路](https://www.acwing.com/problem/content/853/)

给定一个n个点m条边的有向图，图中可能存在重边和自环， **边权可能为负数**。

请你求出1号点到n号点的最短距离，如果无法从1号点走到n号点，则输出impossible。

数据保证不存在负权回路。

- 输入格式

第一行包含整数n和m。

接下来m行每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。

- 输出格式

输出一个整数，表示1号点到n号点的最短距离。

如果路径不存在，则输出”impossible”。

- 数据范围

1≤n,m≤10^5^
图中涉及边长绝对值均不超过10000。

- 输入样例：

```
3 3
1 2 5
2 3 -3
1 3 4
```

- 输出样例：

```
2
```

- 题解：

  ```c++
  #include<iostream>
  #include<cstring>
  #include<queue>
  using namespace std;
  
  int n,m;
  const int N=1e5+10;
  int h[N],w[N],e[N],ne[N],idx;
  bool st[N];
  int dist[N];
  
  void add(int x,int y,int z){
      e[idx]=y,w[idx]=z,ne[idx]=h[x],h[x]=idx++;
  }
  
  int spfa(){
  	memset(dist,0x3f,sizeof dist);
      dist[1]=0;
      
      queue<int>q;
      q.push(1);
      st[1]=true;
      
      while(q.size()){
          int t = q.front();
          q.pop();
          st[t]=false;
          
          for(int i=h[t];i!=-1;i=ne[i]){
              int j=e[i];
              if(dist[j]>dist[t]+w[i]){
                  dist[j]=dist[t]+w[i];
                  if(!st[j]){
                      q.push(j);
                      st[j]=true;
                  }
              }
              
          }         
      }
        if(dist[n]==0x3f3f3f3f) return -1;
          else return dist[n];
  }
  
  int main(int argc,char* argv[]){
      memset(h,-1,sizeof h);
      
      cin>>n>>m;
      for(int i=0;i<m;i++){
          int x,y,z;
          cin>>x>>y>>z;
          add(x,y,z);
      }
      
      int t = spfa();
      
      if(t==-1){puts("impossible");}
      else {cout<<t<<endl;}
      
      return 0;
  }
  
  ```

  



#### 5.spfa判断图中是否存在负环

![1614674525466](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1614674525466.png)

- 时间复杂度是 O(nm)O(nm), nn 表示点数，mm 表示边数

```c++
int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N], cnt[N];        // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点								//数
							//假设dist[N]代表点N到虚拟源点的距离，且全部点到源点距离为0
bool st[N];     // 存储每个点是否在队列中

// 如果存在负环，则返回true，否则返回false。
bool spfa()
{
    // 不需要初始化dist数组
    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。

    queue<int> q;
    for (int i = 1; i <= n; i ++ )
    {
        q.push(i);
        st[i] = true;
    }

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] >= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    return false;
}
```

- 模板题 [AcWing 852. spfa判断负环](https://www.acwing.com/problem/content/854/)

  给定一个n个点m条边的有向图，图中可能存在重边和自环， **边权可能为负数**。

  请你判断图中是否存在负权回路。

  - 输入格式

  第一行包含整数n和m。

  接下来m行每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。

  - 输出格式

  如果图中**存在**负权回路，则输出“Yes”，否则输出“No”。

  - 数据范围

  1≤n≤2000
  1≤m≤10000
  图中涉及边长绝对值均不超过10000。

  - 输入样例：

  ```
  3 3
  1 2 -1
  2 3 4
  3 1 -4
  ```

  - 输出样例：

  ```
  Yes
  ```

- 题解：

  ```c++
  #include<iostream>
  #include<stdio.h>
  #include<cstring>
  #include<queue>
  
  using namespace std;
  
  const int N = 2010;
  int h[N],w[N],e[N],ne[N],idx;
  bool st[N];
  int n,m;
  int dist[N],cnt[N];
  
  void add(int a,int b,int c){
      e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;
  }
  
  bool spfa(){
      memset(si)
  	queue<int>q;
      for(int i = 1;i<=n;i++){
      	q.push(i);
          st[i]=true;
      }
      
      while(q.size()){
          int t = q.front();
          q.pop();
          st[t]=false;
          
          for(int i = h[t] ; i!=-1 ;i=ne[i]){
              int j=e[i];
              if(dist[j]>dist[t]+w[i]){
                  dist[j]=dist[t]+w[i];
              	cnt[j]=cnt[t]+1;
                  if(cnt[j]>=n) return true;
                  if(!st[j]){
                      q.push(j);
                      st[j]=true;
                  }
              }   
          }
      }
      return false;
  }
  
  int main(){
  	memset(h,-1,sizeof h );
      cin>>n>>m;
      for(int i=0;i<m;i++){
          int a,b,c;
          scanf("%d%d%d",&a,&b,&c);
          add(a,b,c);
          
      }
      
     
      
   if (spfa()) puts("Yes");
      else puts("No");
      
      return 0;
  }
  ```

  ```c++
  #include<iostream>
  #include<stdio.h>
  #include<cstring>
  #include<queue>
  
  using namespace std;
  
  const int N = 2010;
  int h[N],w[N],e[N],ne[N],idx;
  bool st[N];
  int n,m;
  int dist[N],cnt[N];
  queue<int>q;
  
  void add(int a,int b,int c){
      e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;
  }
  
  bool spfa(){
      memset(dist, 0x3f, sizeof dist);
      for (int i = 1; i <= n; i++) {
          q.push(i);
          st[i] = true;
      }
      st[1] = true;
      while (q.size()) {
          int t = q.front();
          q.pop();
          st[t] = false;
          for (int i = h[t]; i != -1; i = ne[i]) {
              int j = e[i];
              if (dist[j] > dist[t] + w[i]) {
                  dist[j] = dist[t] + w[i];
                  cnt[j] = cnt[t] + 1;
                  // 如果超过了n-1 
                  // 根据抽屉原理，说明经过某个节点两次，则说明有环
                  if (cnt[j] >= n) return true;
                  if (!st[j]) {
                      st[j] = true;
                      q.push(j);
                  }
              }
          }
      }
      return false;
  }
  
  int main(){
  	memset(h,-1,sizeof h );
      cin>>n>>m;
      for(int i=0;i<m;i++){
          int a,b,c;
          scanf("%d%d%d",&a,&b,&c);
          add(a,b,c);
          
      }
      
     
      
   if (spfa()) puts("Yes");
      else puts("No");
      
      return 0;
  }
  ```

  





#### 7.floyd算法

![1614675565731](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1614675565731.png)



- 时间复杂度是 O(n3)O(n3), nn 表示点数

```
初始化：
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            if (i == j) d[i][j] = 0;
            else d[i][j] = INF;

// 算法结束后，d[a][b]表示a到b的最短距离
void floyd()
{
    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}
```

- 模板题 [AcWing 854. Floyd求最短路](https://www.acwing.com/problem/content/856/)

给定一个n个点m条边的有向图，图中可能存在重边和自环，边权可能为负数。

再给定k个询问，每个询问包含两个整数x和y，表示查询从点x到点y的最短距离，如果路径不存在，则输出“impossible”。

数据保证图中不存在负权回路。

- 输入格式

第一行包含三个整数n，m，k

接下来m行，每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。

接下来k行，每行包含两个整数x，y，表示询问点x到点y的最短距离。

- 输出格式

共k行，每行输出一个整数，表示询问的结果，若询问两点间不存在路径，则输出“impossible”。

- 数据范围

1≤n≤200
1≤k≤n^2^
1≤m≤20000
图中涉及边长绝对值均不超过10000。

- 输入样例：

```
3 3 2
1 2 1
2 3 2
1 3 1
2 1
1 3
```

- 输出样例：

```
impossible
1
```

- 题解

  ```c++
  #include<iostream>
  #include<cstring>
  #include<stdio.h>
  #define INF 1e9
  
  using namespace std;
  
  const int N = 210;
  int dist[N][N];
  
  int n,m,k;
  
  void floyd(){
  	for(int l=1;l<=n;l++){
  		for(int i=1;i<=n;i++){
              for(int j=1;j<=n;j++){
                  dist[i][j]=min(dist[i][j],dist[i][l]+dist[l][j]);
              }
          }
      }
  }
  
  int main(int argc,char * argv[]){
      cin>>n>>m>>k;
      for(int i=1;i<=n;i++){
          for(int j=1;j<=n;j++){
              if(i==j) dist[i][j]=0;
              else dist[i][j]=INF;
          }
      }
      
      for(int i=0;i<m;i++){
          int x,y,z;
          scanf("%d%d%d",&x,&y,&z);
          dist[x][y]=min(dist[x][y],z);
          
      }
      
      floyd();
      
      while(k--){
          int x,y;
          scanf("%d%d",&x,&y);
          if(dist[x][y]>INF/2) cout<<"impossible"<<endl;
          else cout<<dist[x][y]<<endl;
          
      }
  }
  ```

  

