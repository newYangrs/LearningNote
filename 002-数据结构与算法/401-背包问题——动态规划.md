## 背包问题——动态规划



### 0-1背包问题

![1615188272582](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1615188272582.png)

#### 例题：

有 N件物品和一个容量是 V 的背包。每件物品只能使用一次。

第 ii 件物品的体积是 v~i~，价值是 w~i~。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

#### 输入格式

第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。

接下来有 NN 行，每行两个整数 v~i~,w~i~用空格隔开，分别表示第 ii 件物品的体积和价值。

#### 输出格式

输出一个整数，表示最大价值。

#### 数据范围

0<N,V≤1000
0<vi,wi≤1000

#### 输入样例

```
4 5
1 2
2 4
3 4
4 5
```

#### 输出样例：

```
8
```

#### 解法一：

```c++
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 1005;
int v[N],w[N];
int F[N][N];

int main(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>v[i]>>w[i];
    }
    
    for(int i=1;i<=n;i++){
        for(int j=0;j<=m;j++){
            if(j<v[i]){
                F[i][j]=F[i-1][j];
            }else{
                F[i][j]=max(F[i-1][j],F[i-1][j-v[i]]+w[i]);
            }
        }
    }
    
    cout<<F[n][m]<<endl;
    
    return 0;
    
}
```

#### 解法二：

```c++
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 1005;
int v[N],w[N];
int f[N];

int main(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>v[i]>>w[i];
    }
    for(int i=1;i<=n;i++){
        for(int j=m;j>=v[i];j--){
            f[j]=max(f[j],f[j-v[i]]+w[i]);
        }
    }
    
    cout<<f[m]<<endl;
    
    return 0;
}
```





### 完全背包问题

![1615196473348](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1615196473348.png)

- 朴素方程

![1615196687274](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1615196687274.png)

- 优化方程

  ![1615276023296](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1615276023296.png)

#### 例题

有 NN 种物品和一个容量是 V 的背包，每种物品都有无限件可用。

第 ii 种物品的体积是 v~i~，价值是 w~i~。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

#### 输入格式

第一行两个整数，N，V用空格隔开，分别表示物品种数和背包容积。

接下来有 NN 行，每行两个整数 vi,wivi,wi，用空格隔开，分别表示第 ii 种物品的体积和价值。

#### 输出格式

输出一个整数，表示最大价值。

#### 数据范围

0<N,V≤1000
0<v~i~,w~i~≤1000

#### 输入样例

```
4 5
1 2
2 4
3 4
4 5
```

#### 输出样例：

```
10
```

#### 朴素解法（三维）：

```c++
#include<iostream>
#include<stdio.h>
using namespace std;

const int N = 1010;
int v[N],w[N];
int f[N][N];

int main(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>v[i]>>w[i];
    }
    
    for(int i=1;i<=n;i++){
        for(int j=0;j<=m;j++){
            for(int k=0;j>=k*v[i];k++){
                f[i][j]=max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]);
            }
        }
    }
    
    cout<<f[n][m]<<endl;
    
    return 0;
    
}
```

#### 优化写法（二维）：

```c++
#include<iostream>
#include<stdio.h>
using namespace std;

const int N = 1010;
int v[N],w[N];
int f[N][N];

int main(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>v[i]>>w[i];
    }
    
    for(int i=1;i<=n;i++){
        for(int j=0;j<=m;j++){
            f[i][j]=f[i-1][j];
            if(j>=v[i]){
                f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]);
            }
        }
    }
    
    cout<<f[n][m]<<endl;
    
    return 0;
    
}
```

#### 最终优化（一维）：

```c++
#include<iostream>
#include<stdio.h>
using namespace std;

const int N = 1010;
int v[N],w[N];
int f[N];

int main(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>v[i]>>w[i];
    }
    
    for(int i=1;i<=n;i++){
        for(int j=v[i];j<=m;j++){
            
                f[j]=max(f[j],f[j-v[i]]+w[i]);
            
        }
    }
    
    cout<<f[m]<<endl;
    
    return 0;
    
}
```





### 多重背包

#### 朴素版：

![1615357872592](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1615357872592.png)

![1615357269996](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1615357269996.png)

- **例题一**

有 N 种物品和一个容量是 V 的背包。

第 ii 种物品最多有 s~i~件，每件体积是 v~i~，价值是 w~i~。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。

#### 输入格式

第一行两个整数，N，V用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行三个整数 v~i~,w~i~,s~i~用空格隔开，分别表示第 i种物品的体积、价值和数量。

#### 输出格式

输出一个整数，表示最大价值。

#### 数据范围

0<N,V≤100
0<v~i~,w~i~,s~i~≤100

#### 输入样例

```
4 5
1 2 3
2 4 1
3 4 3
4 5 2
```

#### 输出样例：

```
10
```

#### 题解：

```c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 105 ;
int v[N],w[N],s[N];
int f[N][N];

int main(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
		cin>>v[i]>>w[i]>>s[i];
    }
    
    for(int i=1;i<=n;i++){
        for(int j=0;j<=m;j++){
            for(int k=0;k<=s[i]&&j>=k*v[i];k++){
                f[i][j]=max(f[i][j],f[i-1][j-v[i]*k]+k*w[i]);
            }
        }
    }
    
    cout<<f[n][m]<<endl;
    
    return 0;
    
}
```





#### 优化版：

![1615357762501](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1615357762501.png)

![1615358472018](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1615358472018.png)

![1615358609710](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1615358609710.png)



![1615363550188](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1615363550188.png)

![1615363445032](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1615363445032.png)



#### 例题二：

#### 题解：

```c++

```





### 分组背包问题



![1615359674003](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1615359674003.png)

#### 例题：

有 N 组物品和一个容量是 V 的背包。

每组物品有若干个，同一组内的物品最多只能选一个。
每件物品的体积是 v~ij~，价值是 w~ij~，其中 i 是组号，j 是组内编号。

求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。

输出最大价值。

#### 输入格式

第一行有两个整数 N，V用空格隔开，分别表示物品组数和背包容量。

接下来有 N 组数据：

- 每组数据第一行有一个整数 S~i~，表示第 i个物品组的物品数量；
- 每组数据接下来有 S~i~行，每行有两个整数 v~ij~,w~ij~，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值；

#### 输出格式

输出一个整数，表示最大价值。

#### 数据范围

0<N,V≤100
0<S~i~≤100
0<v~ij~,w~ij~≤100

#### 输入样例

```
3 5
2
1 2
2 4
1
3 4
1
4 5
```

#### 输出样例：

```
8
```

#### 题解：

```c++
#include<iostream>

```

