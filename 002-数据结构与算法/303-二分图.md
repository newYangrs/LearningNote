## 二分图

### 分类：



![1615011772433](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1615011772433.png)



![1615011684707](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1615011684707.png)



### 一、染色法





<img src="C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1615012095444.png" alt="1615012095444" style="zoom:150%;" />

- 染色法判别二分图

- 时间复杂度是 O(n+m)O(n+m), nn 表示点数，mm 表示边数

```c++
int n;      // n表示点数
int h[N], e[M], ne[M], idx;     // 邻接表存储图
int color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色

// 参数：u表示当前节点，c表示当前点的颜色
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }

    return true;
}

bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```

-   模板题 [AcWing 860. 染色法判定二分图](https://www.acwing.com/problem/content/862/)

  给定一个n个点m条边的无向图，图中可能存在重边和自环。

  请你判断这个图是否是二分图。

  - 输入格式

  第一行包含两个整数n和m。

  接下来m行，每行包含两个整数u和v，表示点u和点v之间存在一条边。

  - 输出格式

  如果给定图是二分图，则输出“Yes”，否则输出“No”。

  - 数据范围

  1≤n,m≤10^5^

  - 输入样例：

  ```
  4 4
  1 3
  1 4
  2 3
  2 4
  ```

  - 输出样例：

  ```
  Yes
  ```

- 题解：

  ```c++
  #include<iostream>
  #include<algorithm>
  #include<cstring>
  
  using namespace std;
  
  const int N=1e5+10,M=2e5+10;
  int h[N],e[M],ne[M],idx;
  int colors[N];
  
  void add(int a,int b){
      e[idx]=b,ne[idx]=h[a],h[a]=idx++;
  }
  
  bool dfs(int u,int c){
      colors[u]=c;
      for(int i=h[u];i!=-1;i=ne[i]){
          int j=e[i];
          if(!colors[j]){
              if(!dfs(j,3-c)){
                  return false;
              }
          }else if(colors[j]==c){
              return false;
          }
      }
      return true;
  }
  
  int main(){
      int n,m;
      scanf("%d%d",&n,&m);
      
      memset(h,-1,sizeof h);
      while(m--){
          int a,b;
          scanf("%d%d",&a,&b);
          add(a,b),add(b,a);
      }
      
      bool flag=true;
      for(int i=1;i<=n;i++){
          if(!colors[i]){
              if(!dfs(i,1)){
                  flag=false;
                  break;
              }
          }
      }
      
      if(!flag) puts("No");
      else puts("Yes");
      
      return 0;
  }
  ```

  





### 二、匈牙利法

![1615013809832](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1615013809832.png)



- 时间复杂度是 O(nm)O(nm), nn 表示点数，mm 表示边数

```c++
int n1, n2;     // n1表示第一个集合中的点数，n2表示第二个集合中的点数
int h[N], e[M], ne[M], idx;     // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边
int match[N];       // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个
bool st[N];     // 表示第二个集合中的每个点是否已经被遍历过

bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }

    return false;
}

// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点
int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```

-  模板题 [AcWing 861. 二分图的最大匹配](https://www.acwing.com/problem/content/863/)

给定一个二分图，其中左半部包含n~1~个点（编号1\~n~1~），右半部包含n2n2个点（编号1\~n~2~），二分图共包含m条边。

数据保证任意一条边的两个端点都不可能在同一部分中。

请你求出二分图的最大匹配数。

> 二分图的匹配：给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。
>
> 二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。

- 输入格式

第一行包含三个整数 n~1~、 n~2~ 和 m。

接下来m行，每行包含两个整数u和v，表示左半部点集中的点u和右半部点集中的点v之间存在一条边。

- 输出格式

输出一个整数，表示二分图的最大匹配数。

- 数据范围

1≤n1,n2≤500
1≤u≤n~1~
1≤v≤n~2~
1≤m≤10^5^

- 输入样例：

```
2 2 4
1 1
1 2
2 1
2 2
```

- 输出样例：

```
2
```

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;

const int N=500,M=1e5+10;
int h[N],e[M],ne[M],idx;
int match[N];
bool st[N];

void add(int a,int b){
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}

bool find(int x){
    for(int i=h[x];i!=-1;i=ne[i]){
        int j=e[i];
        if(!st[j]){
            st[j]=true;
            if(match[j]==0 || find(match[j])){
                match[j]=x;
                return true;
            }
        }
    }
    return false;
    
}

int main(){
    int n1,n2,m;
    scanf("%d%d%d",&n1,&n2,&m);
    
    memset(h,-1,sizeof h);
    while(m--){
        int a,b;
        scanf("%d%d",&a,&b);
        add(a,b);
    }
    
    int res=0;
    
    for(int i=1;i<=n1;i++){
        memset(st,false,sizeof st);
        if(find(i)){
            res++;
        }
    }
    
    printf("%d\n",res);
    
    return 0;
    
    
    
}

```

