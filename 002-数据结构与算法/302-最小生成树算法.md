## 最小生成树算法

### 分类：

![1614839153794](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1614839153794.png)



### 一、Prim

- #### 朴素版prim

![朴素版Prim](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1614839934690.png)



- 朴素版prim算法

- 时间复杂度是 O(n2+m)O(n2+m), nn 表示点数，mm 表示边数

```c++
int n;      // n表示点数
int g[N][N];        // 邻接矩阵，存储所有边
int dist[N];        // 存储其他点到当前最小生成树的距离
bool st[N];     // 存储每个点是否已经在生成树中


// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和
int prim()
{
    memset(dist, 0x3f, sizeof dist);

    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        if (i && dist[t] == INF) return INF;

        if (i) res += dist[t];
        st[t] = true;

        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }

    return res;
}
```

- **例题：模板题 [AcWing 858. Prim算法求最小生成树](https://www.acwing.com/problem/content/860/)**

  **给定一个n个点m条边的无向图，图中可能存在重边和自环，边权可能为负数。**

  **求最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。**

  **给定一张边带权的无向图G=(V, E)，其中V表示图中点的集合，E表示图中边的集合，n=|V|，m=|E|。**

  **由V中的全部n个顶点和E中n-1条边构成的无向连通子图被称为G的一棵生成树，其中边的权值之和最小的生成树被称为无向图G的最小生成树。**

  - 输入格式

  第一行包含两个整数n和m。

  接下来m行，每行包含三个整数u，v，w，表示点u和点v之间存在一条权值为w的边。

  - 输出格式

  共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。

  - 数据范围

  1≤n≤500
  1≤m≤10^5^
  图中涉及边的边权的绝对值均不超过10000。

  - 输入样例：

  ```
  4 5
  1 2 1
  1 3 2
  1 4 3
  2 3 2
  3 4 4
  ```

  - 输出样例：

  ```
  6
  ```

- 题解：

  ```c++
  #include<iostream>
  #include<stdio.h>
  #include<cstring>
  #include<algorithm>
  
  
  using namespace std;
  
  const int INF=0x3f3f3f3f;
  const int N = 510;
  int g[N][N];	//稠密图
  int dist[N];	//距离集合的最小距离
  bool st[N];		//标记是否在集合中
  int n,m;
  
  int prim(){
      memset(dist,0x3f,sizeof dist);//初始化所有点到集合的距离
      
      int res = 0;
      
      for(int i=0;i<n;i++){
          int t=-1;
          for(int j=1;j<=n;j++){
              if(!st[j]&&(t==-1 || dist[t]>dist[j])){
                  t=j;
              }
          }
          
          if(i&&dist[t]==INF)	return INF;
          
          if(i!=0)	res += dist[t];
          st[t]=true;
          
          for(int j=1;j<=n;j++){
              dist[j]=min(dist[j],g[t][j]);
          }
          
      }
      
      return res;
  }
  
  
  int main(){
      memset(g,0x3f,sizeof g);
      
      cin>>n>>m;
      //边初始化
      for(int i=0;i<m;i++){
          int a,b,c;
          cin>>a>>b>>c;
          g[a][b]=g[b][a]=min(g[a][b],c);
          
      }
      
      int res = prim();
      
      if(res==INF) puts("impossible");
      else printf("%d\n",res);
      
      return 0;
      
  }
  
  ```

  



- 堆优化版Prim  ——参考dijkstra算法的堆优化





### 二、kruskal算法

![1614846293445](C:\Users\Mr.Yang\AppData\Roaming\Typora\typora-user-images\1614846293445.png)



- Kruskal算法 

- 时间复杂度是 O(mlogm)O(mlogm), nn 表示点数，mm 表示边数

```c++
int n, m;       // n是点数，m是边数
int p[N];       // 并查集的父节点数组

struct Edge     // 存储边
{
    int a, b, w;

    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];

int find(int x)     // 并查集核心操作
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int kruskal()
{
    sort(edges, edges + m);

    for (int i = 1; i <= n; i ++ ) p[i] = i;    // 初始化并查集

    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;

        a = find(a), b = find(b);
        if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }

    if (cnt < n - 1) return INF;
    return res;
}
```

-  模板题 [AcWing 859. Kruskal算法求最小生成树](https://www.acwing.com/problem/content/861/)

  给定一个n个点m条边的无向图，图中可能存在重边和自环，边权可能为负数。

  求最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。

  给定一张边带权的无向图G=(V, E)，其中V表示图中点的集合，E表示图中边的集合，n=|V|，m=|E|。

  由V中的全部n个顶点和E中n-1条边构成的无向连通子图被称为G的一棵生成树，其中边的权值之和最小的生成树被称为无向图G的最小生成树。

  - **输入格式**

  第一行包含两个整数n和m。

  接下来m行，每行包含三个整数u，v，w，表示点u和点v之间存在一条权值为w的边。

  - **输出格式**

  共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。

  - **数据范围**

  1≤n≤10^5^
  1≤m≤2∗10^5^
  图中涉及边的边权的绝对值均不超过1000。

  - **输入样例：**

  ```
  4 5
  1 2 1
  1 3 2
  1 4 3
  2 3 2
  3 4 4
  ```

  - **输出样例：**

  ```
  6
  ```

- **题解：**

  ```c++
  #include<iostream>
  #include<cstring>
  #include<stdio.h>
#include<algorithm>
  
  using namespace std;
  
  const int N=1e5+10,M=N*2;
  int n,m;
  int p[N];
  
  int find(int x){
      if(p[x]!=x)	p[x]=find(p[x]);
      return p[x];
      
  }
  
  struct edge{
      int a,b,w;
      bool operator<(const edge&W)const{
          return w<W.w;
      }
      
  }edges[M];
  
  
  int main(int argc,char*argv[]){
      
      cin>>n>>m;
      
      for(int i=1;i<=n;i++){
          p[i]=i;
      }
      
      
      for(int i=0;i<m;i++){
          int a,b,w;
          scanf("%d%d%d",&a,&b,&w);
          edges[i]={a,b,w};
      }
      
      sort(edges,edges+m);
      
      int res = 0,cnt=0;
      for(int i=0;i<n;i++){
          int a=edges[i].a,b=edges[i].b,w=edges[i].w;
          
          a=find(a),b=find(b);
          if(a!=b){
              
              p[a]=b;
              res+=w;
              cnt++;
          }
      }
      
      if(cnt==n-1){
             cout<<res<<endl;
        
      }else{
        puts("impossible");
     
      }
      return 0;
  }
  
  ```
  
  